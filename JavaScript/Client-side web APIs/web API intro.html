<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web APIs intro</title>
  </head>
  <body>
    <h1>Web APIs intro</h1>
    <p>
      虽然已经用了很久的API了，但是我们还没有正式介绍过，我们现在来细看一下web
      API的使用方式，工作原理等等
    </p>
    <h2>What's API</h2>
    <p>
      Applcation Programming
      interface，或API，为一种编程语言内让我们实现复杂功能的construct，他们把比较复杂的实现方式变成了一小段简单的语法
    </p>
    <p>
      给一个irl例子，如果我想用电器，那我只需要把电器的插头插上即可，我不需要自己手动链接电器和供电。而编程也差不多，如果我想要创造一些
      3d动画，我肯定不会直接从系统底层语言比如c++开始写，而是使用更加高层的语言提供便捷的操作
    </p>
    <h3>客户端JS API</h3>
    <p>
      客户端JS有很多API，这些其实不是JS语言的一部分，而是基于JS核心的，让我们对JS有更多可能性的代码：
    </p>
    <ul>
      <li>
        <b>Browser APIs</b>
        为直接内置在浏览器内的，并且可以从浏览器或电脑环境传输数据并且进行操作。比如<a
          href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API"
          >Web audio api</a
        >提供了JS
        construct用于在浏览器内操作音频。比如更改音量，提取音轨，加特效等等。而在后台，浏览器其实是在使用底层语言，比如C++或者Rust，来进行操作，不过这些复杂的语言被API直接掩盖住了，所以我不用学他
      </li>
      <li>
        <b>Third party APIs</b
        >默认不是内置在浏览器内的，这些API一般需要从他们的官方网页提出代码来运行，比如<a
          href="https://developer.twitter.com/en/docs"
          >Twitter API</a
        >就可以允许我们做一些和推特有关的操作，比如展示某个人的最新推文等等
      </li>
    </ul>
    <h3>JS, APIs and other JS tools</h3>
    <p>现在我们对API有了更深的理解，我们来把一些名词捋一下：</p>
    <ul>
      <li>
        JavaScript:
        高层编程语言，内置在浏览器内，允许我们对网页/app实现功能。注意JS也可以在其他编程环境使用，比如<a
          href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction"
          >Node</a
        >
      </li>
      <li>
        Browser API:
        基于浏览器和JS核心语言的construct，可以帮我们用简单方法实现难题
      </li>
      <li>
        3rd party
        APIs：基于第三方平台的construct，允许我们在自己的代码里使用这些平台的部分功能
      </li>
      <li>
        JS
        libraries，一般来说可以使用一到两个JS库来加快编写速度，比较常见的库有jQuery,
        React和Mootools
      </li>
      <li>
        JS frameworks，这是库的下一步。JS
        framework，比如<code>Angular</code>和<code>Ember</code>一般来说是HTML，CSS，JS以及其他可能写从0写网页用到的科技。库和框架的本质区别是"inversion
        of
        control"，当我们从库里面使用函数的时候，我们作为开发者在控制method，对于框架则是相反的，框架call我们的代码
      </li>
    </ul>
    <h2>What can API do</h2>
    <p>现代浏览器内有许多api，我们按照种类和常用性分一下：</p>
    <h3>Common browser APIs</h3>
    <p>一般来说，我们最常见到的API有下面这些：</p>
    <ul>
      <li>
        <b>API for manipulating document</b>: 最常见的是<code>DOM</code>
        API，可以允许我们更改HTML和CSS，动态添加，减少和更改元素。一般来说当我们的网页出现了新的内容，或者弹窗，那么都是DOM的结果。
      </li>
      <li>
        <b>API for fetching data from server</b
        >，这种API一般用于从服务器提取信息，然后加在网页上用于更新。这种小功能可以提升很大的用户体验，因为我不用为了一小块内容来重置整个网页。主要的API是<code>fetch()</code>，更老一点的代码可能会使用<code
          >XMLHttpRequest</code
        >
        API，后面还会学习<b>Ajax</b>，也就是类似上面这种的技巧。
      </li>
      <li>
        <b>API for drawing and manipulating graphics</b
        >，浏览器支很广，比较受欢迎的是Canvas和WebGL，都允许我们使用html的<code>canvas</code>元素来动态更改像素的显示。比如我可以使用WebGL来创建3d形状，使用canvas来画图，给图片上滤镜等等。这些API一般来说会和<code
          >window.requestAnimationFrame()</code
        >
        API这种创建动画的API联合使用
      </li>
      <li>
        Audio and Video APIs，比如<code>HTMLMediaElement</code>,
        <code>Web Audio API</code>，
        <code>WebRTC</code>等等允许我们做一些很有趣的音视频操作，
        比如自定义控制UI，加音效，展示字幕，操作摄像头等等
      </li>
      <li>
        <b>Device APIs</b>: 允许我们向设备硬件交互，比如获得GPS来使用<code
          >Geolocaiton</code
        >
        API
      </li>
      <li>
        <b>Client-side storage APIs</b>：
        允许我们在客户端来储存数据以便下次加载更快，甚至可以离线操作。这些有几个API可以实现，比如简单的Web
        Storage API，和稍微难一点的IndexedDB API
      </li>
    </ul>
    <h3>Common 3rd party apis</h3>
    <p>第三方API有很多种，这里列下一点比较常见比较常用的:</p>
    <ul>
      <li>Twitter API，允许我们加Tweet</li>
      <li>MAP APIs，比如google map和Mapquest，在网页添加地图</li>
      <li>
        Facebook suite of APIs，允许我们使用fb的生态部分，比如允许fb登录等等
      </li>
      <li>Telegram API，允许display channel最新内容和机器人支持</li>
      <li>YouTubue API，嵌入视频，搜索视频，创建列表等等</li>
      <li>Pinterest，允许管理图片board</li>
      <li>Twilio API，提供了打电话，视频和发短信的框架</li>
      <li>Mastodon API，允许我们操作Mastodon social network的功能</li>
    </ul>
    <h2>how do API works</h2>
    <p>不同的JS API有不同的操作方式，但是总的来说他们是有类似处的。</p>
    <h3>They are based on objects</h3>
    <p>
      我们的代码会使用一个或多个JS object来向API交互。
      这些object将会作为API的数据和功能container使用（也就是properties和methods）
    </p>
    <p>
      回到刚刚的web audio
      API，这个是一个比较复杂的API，内含了多个object，比较常用的是：
    </p>
    <ul>
      <li>
        <code>AudioContext</code>，代表了一个可以操作音频播放的audio
        graph，且内含许多methods
      </li>
      <li>
        <code>MediaElementAudioSourceNode</code
        >，代表&lt;audio&gt;元素，内含我们想要操作和播放的在audio
        context内的音乐
      </li>
      <li>
        <code>AudioDestinationNode</code
        >，代表了audio的denstination，也就是输出端，比如音响或耳机
      </li>
    </ul>
    <p>
      这些Object是API的核心功能，我们需要知道他们之间是怎么互动怎么实现功能的，首先看一下下面的一个简单音乐播放器
    </p>
    <audio src="../Resources/port Ormos.mp3"></audio>
    <button class="paused">Play</button>
    <br />
    <input type="range" min="0" max="1" step="0.01" class="volume" value="1" />
    <p>
      这里的html代码很简单，直接略过，需要知道的就是我们有一个<code>&lt;audio&gt;</code>，一个<code>&lt;button&gt;</code>和一个<code>&lt;input&gt;</code>，分别对应音频源，按钮和音量(以input的range实现)
    </p>
    <pre>
      const AudioContext = window.AudioContext || window.webkitAduioContext;
      const audioCtx = new AudioContext();

      const audioElement = document.querySelector("audio");
      const playBtn = document.querySelector("button");
      const volumeSlider = document.querySelector(".volume");

      const audioSource = audioCtx.createMediaElementSource(audioElement);
    </pre>
    <p>
      在JS代码内，首先我们创建了一个<code>AudioContext</code>(音乐处理graph)的实例，然后把三个相关的button存在变量内。
      最后再使用<code>AudioContext.createMediaElementSource()</code>函数来创建一个<code>MediaElementAudioSourceNode</code>来代表我们的音源，也就是&lt;audio&gt;
    </p>
    <pre>
      playBtn.addEventListener("click", () => {
        if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }

        if (playBtn.getAttribute("class") === "paused") {
          audioElement.play();
          playBtn.setAttribute("class", "playing");
          playBtn.textContent = "Pause";
        } else if (playBtn.getAttribute("class") === "playing") {
          audioElement.pause();
          playBtn.setAttribute("class", "paused");
          playBtn.textContent = "Play";
        }
      });
    </pre>
    <p>
      然后就是控制button的代码了，我们首先给button上一个eventlistener，然后在里面进行多个判断:
    </p>
    <ul>
      <li>
        如果音频停止了，也就是<code>audioCtx.state === 'suspended'</code
        >，则从之前停止的地方继续播放
      </li>
      <li>如果button为paused，则把他切换成playing，然后暂停歌曲</li>
      <li>如果button是playing，则相反，切换成paused，继续歌曲</li>
    </ul>
    <p>
      这里需要注意一下，我们使用的<code>audioElement.play()</code>和pause()并不是web
      audio API内的，而是HTMLMediaElement部分的。
    </p>
    <pre>
    const gainNode = audioCtx.createGain();

    volumeSlider.addEventListener('input', () => {
      gainNode.gain.value = volumeSlider.value;
    });
    </pre>
    <p>
      这段代码创建了一个使用<code>AudioContext.createGain()</code>创建了一个<code
        >GainNode</code
      >
      object，这个object可以用来调整音乐的音量。
      然后给刚刚的input附上eventlistener，把他和audio
      graph的gain，也就是音量连接起来
    </p>
    <pre>
      audioSource.connect(gainNode).connect(audioCtx.destination);
    </pre>
    <p>
      最后一件事就是则是把各个audio
      graph内的node使用使用<code>AduioNode.connect()</code>连接起来。首先是音乐从source开始，连接到gainNode以调整音量，然后gainNode连接到destination
      node以输出到电脑端
    </p>
    <h3>Entry points</h3>
    <p>
      当使用API的时候，我们应该知道API对应的entry point，对于刚刚的web audio
      API来说则是<code>AudioContext</code> object，相当于是一个interface
    </p>
    <p>
      而对于Document Object Model (DOM) API来说，则是<code>Document</code>
      Object或者是任意想要调整的HTML元素实例，比如<code>document.querySelector()</code>等等
    </p>
    <p>
      对于Canvas
      API来说，它也需要一个context来实现操作，不过这里的context就不是audio
      context而是graphic
      context。通过向<code>&lt;canvas&gt;</code>附上一个reference然后<code>.getContext</code>即可
    </p>
    <pre>
      const canvas = document.querySelector('canvas');
      const ctx = canvas.getContext('2d');
    </pre>
    <p>
      而任何想要对canvas进行的更改，都需要对context object来调整。比如之前的<a
        href="../MDN practice/bouncing ball updated.html"
        >bouncing ball例子</a
      >
    </p>
    <pre>
      Ball.prototype.draw = function(){
        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.arc(this.x, this.y, this.szie, 0, 2 *Math.PI);
        ctx.fill();
      }
    </pre>
    <h3>Use of events</h3>
    <p>
      在前面就提过了event的概念。而许多网页API均还有events，这些handler可以帮助我们运行某些功能。其实在刚刚的web
      audio内就已经用到了：
    </p>
    <pre>
      playBtn.addEventListener("click", () => {
        if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }

        if (playBtn.getAttribute("class") === "paused") {
          audioElement.play();
          playBtn.setAttribute("class", "playing");
          playBtn.textContent = "Pause";
        } else if (playBtn.getAttribute("class") === "playing") {
          audioElement.pause();
          playBtn.setAttribute("class", "paused");
          playBtn.textContent = "Play";
        }
      });

      audioElement.addEventListener("ended", () => {
        playBtn.setAttribute("class", "paused");
        playBtn.textContent = "Play";
      });
    </pre>
    <h3>security mechanism</h3>
    <p>
      Web
      API功能和JS以及其他网页技术的安全性是差不多的，但是他们有的时候会有额外的security
      mechanism，比如许多现代的WebAPI都仅支持在HTTPS上工作（因为会传输信息）
    </p>
    <p>
      而有的WebAPI要求用户开启才能使用，比如Notification
      API就会用弹窗的形式获得用户的许可。也有的API会有额外的security
      mechanism，比如web audio就需要遵从autoplay
      policy，说简单点就是不能让页面自动放音乐，需要用户许可才行
    </p>
    <script>
      const AudioContext = window.AudioContext || window.webkitAduioContext;
      const audioCtx = new AudioContext();

      const audioElement = document.querySelector("audio");
      const playBtn = document.querySelector("button");
      const volumeSlider = document.querySelector(".volume");

      const audioSource = audioCtx.createMediaElementSource(audioElement);

      playBtn.addEventListener("click", () => {
        if (audioCtx.state === "suspended") {
          audioCtx.resume();
        }

        if (playBtn.getAttribute("class") === "paused") {
          audioElement.play();
          playBtn.setAttribute("class", "playing");
          playBtn.textContent = "Pause";
        } else if (playBtn.getAttribute("class") === "playing") {
          audioElement.pause();
          playBtn.setAttribute("class", "paused");
          playBtn.textContent = "Play";
        }
      });

      audioElement.addEventListener("ended", () => {
        playBtn.setAttribute("class", "paused");
        playBtn.textContent = "Play";
      });

      const gainNode = audioCtx.createGain();

      volumeSlider.addEventListener("input", () => {
        gainNode.gain.value = volumeSlider.value;
      });

      audioSource.connect(gainNode).connect(audioCtx.destination);
    </script>
  </body>
</html>
