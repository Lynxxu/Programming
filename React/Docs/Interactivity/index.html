<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react?dev",
          "react-dom/client": "https://esm.sh/react-dom/client?dev"
        }
      }
    </script>

    <script
      type="text/babel"
      data-type="module"
      src="update object in state.jsx"
    ></script>
    <title>Updating object in state</title>
  </head>
  <body>
    <h1>Updating objects in state</h1>
    <p>
      As shown earlier in our <a href="state.html">state</a> article, state can
      hold numbers and booleans. In fact, they can hold any kind of JS value,
      including objects. However, the object should not be changed in the state
      directly, but rather subsituted for a new one.
    </p>
    <h2>mutation</h2>
    <p>
      Shown in our previous example, with
      <code>const [x, setX] = useState(0);</code>, we are storing a number in
      the state. Numbers, strings and booleans are JS values that are
      <b>immutable</b>, meaning they cannot be changed. When we use
      <code>setX(5)</code>, we are actually replacing the value and triggering a
      re-render. In this case, the <code>x</code> state changed from 0 to 5, but
      the number <code>0</code> is not changed. This also applies for Strings,
      booleans and numbers
    </p>
    <p>
      However, an object in state is mutable, for example,
      <code>const [position, setPosition] = useState ({ x:0, y:0})</code> can be
      updated with <code>position.x = 5</code>. However, this is not
      recommended. We should treat any JS objects that are in the state as
      <b>read-only</b>
    </p>
    <p>The below code is an example that tracts the mouse pointer.</p>
    <div id="movingDot"></div>
    <p>This example is made possible by this line of code:</p>
    <pre>
      onPointerMove={e =&gt; {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
    </pre>
    <p>
      In here, we pass on a new object value to the event handler function. So
      every mouse pointer move would pass a new state, triggering a new render.
      If we simply change the value in the state object like:
    </p>
    <pre>
      onPointerMove={e =&gt; {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
    </pre>
    <p>
      Then it only updates the exisiting <code>position</code> object in the
      state. In this case, no state setter function is used and React would not
      know the object is updated so it is not valid.
    </p>
    <p>
      In this sense, mutation is only a problem when <b>exisitng obejcts</b> are
      updated. It is fine to mutate a object that was just created, as there are
      no other codes referencing it. This is called local mutation.
    </p>
    <h2>copying object with spread</h2>
    <p>
      In the previous example, the <code>position</code> object is always newly
      created from cursor position. However, in many cases, we would wish to
      include exisiting data as a part of new object. For example, updating a
      part of a form while keeping everything else the same.
    </p>
    <p>
      below is a example form that ideally, should combine all cells and return
      a single string containing all informations. However, it is not
      functioning.
    </p>
    <div id="form1"></div>
    <pre>
      function Form1() {
        const [person, setPerson] = useState({
          firstName: "Chalin",
          lastName: "Yang",
          email: "CHALINYANG@GMAIL.com",
        });
      
        function handleFirstNameChange(e) {
          person.firstName = e.target.value;
        }
      
        function handleLastNameChange(e) {
          person.lastName = e.target.value;
        }
      
        function handleEmailChange(e) {
          person.email = e.target.value;
        }
      
        return (
          &lt;&gt;
            &lt;label&gt;
              First name:
              &lt;input value={person.firstName} onChange={handleFirstNameChange} /&gt;
            &lt;/label&gt;
            &lt;label&gt;
              Last name:
              &lt;input value={person.lastName} onChange={handleLastNameChange} /&gt;
            &lt;/label&gt;
            &lt;label&gt;
              Email:
              &lt;input value={person.email} onChange={handleEmailChange} /&gt;
            &lt;/label&gt;
            &lt;p&gt;
              {person.firstName} {person.lastName} ({person.email})
            &lt;/p&gt;
          &lt;/&gt;
        );
      }
    </pre>
    <p>
      Apparently, from the source code we can see that the problem is we are
      mutating the object in state. As mentioned above, we can simply create a
      new object and pass it to trigger a re-render. However, we need to include
      all data that are not changed from previous state. For example, the
      <code>handleFirstNameChange</code> should be changed as follows:
    </p>
    <pre>
      handleFirstNameChange(e){
        setPerson({firstName: e.target.value, lastName: person.lastName, email: person.email})
      }
    </pre>
    <p>
      Well, use the <code>spread</code> syntax, that's <code>...person</code> in
      this case. It can pass all properties of a object into a new one.
      Refractor the above code to below:
    </p>
    <pre>
      handleFirstNameChange(e){
        setPerson({...perosn, firstName: e.target.value})
      }
    </pre>
    <p>
      Change all other handlers using sperad syntax, now the form would work as
      expected:
    </p>
    <div id="form2"></div>
    <p>
      To make the code even more concise, we can use <code>[]</code> braces to
      specify a property with dynamic name. For the above example, we are
      updating first and last name, email, and we wrote a function for each of
      them. They can be all done with one event handler function below. Note
      that the <code>e.target.name</code> here refers to the name property of
      <code>input</code> DOM element
    </p>
    <pre>
      function handleChange(){
        setPerson({
          ...person,
          [e.target.name]:e.target.value
        })
      }
    </pre>
    <h3>Updating a nested object</h3>
    <p>considering a nested object like below:</p>
    <pre>
      const [person, setPerson] = useState({
        name: 'chalin Yang',
        contact:{
          cell: '114514'
          home: '1919801'
          address: 'shimo-kitazawa'
        }
      })
    </pre>
    <p>
      it can easily be mutated using
      <code>person.contact.address: 'Tokyo'</code>. However, in React, we treat
      objects as immutable, so we would have to create a new
      <code>contact</code> object, and create a new <code>person</code> object
      containing that new <code>contact</code>. It can be done as below
    </p>
    <pre>
      setPerson({
        ...person, //copy other fileds
        contact:{ //change contact object
          ...person.contact,  //keep all previous info but change address
          address: 'Tokyo'
        }
      })
    </pre>
    <p>
      As a side note, object within objects are not really nested, the
      <code>person</code> object is essentially one object referencing another
    </p>
    <pre>
      let obj1 = {          
        cell: '114514'
        home: '1919801'
        address: 'shimo-kitazawa'
      
      }
      let obj2 = {name:'chalin Yang', contact:'obj1'}
    </pre>
    <h3>Concise update logic by Immer</h3>
    <p>
      The code above for updating a state is valid but verbose. Objects that are
      deeply nested could be flattened for better codability. However, if state
      structure can't be altered, then we can use <b>Immer</b>, a library which
      enables the convenient mutating syntax for updating a state.
    </p>
    <pre>
      updatePerson(draft =&gt; {draft.contact: 'Tokyo';})
    </pre>
    <p>
      It seems from the code we are mutating the state, but we are not. The
      draft property here is a special object called <code>Proxy</code>, it
      records what was done to it. Immer would then, based on the parts that
      <code>draft</code> was changed, producing a entirely new object that
      reflects all the edits.
    </p>
  </body>
</html>
