<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
      div {
        display: flex;
        justify-content: center;
      }

      img {
        max-width: 100%;
        max-height: 100%;
        display: flex;
        margin: 1em 0 1em 0.5em;
        border: 1px solid black;
      }
    </style>
    <title>Debugging Journal</title>
  </head>
  <body>
    <h1>Clarification</h1>
    <p>
      This webpage is used to note down problems, facts and techniques used with
      bugs I encountered during my study
    </p>

    <h2 id="1">关于p内嵌套其他元素的限制</h2>
    <h3>问题详情:</h3>
    <p>
      2022-07-20，当我试图使用<code>p div</code
      >选择器来选中p内的div元素时，发现没有用，而p + div才有用，因此我将其文档
      <a href="Resources/styling list-copy.html">styling list</a
      >放入了validator查错。发现了如下的问题：
    </p>
    <div>
      <img src="Resources/p and list error.png" />
    </div>
    <p>
      经过了检查，我发现我每一个p都有对应的end tag，这个问题应该不存在才对。：
    </p>
    <h3>解析</h3>
    <p>
      在<a
        href="https://html.spec.whatwg.org/multipage/grouping-content.html#the-p-element"
        >官方文档p的定义</a
      >内，可以看见以下关于tag omission的解释
    </p>
    <blockquote>
      A p element's end tag can be omitted if the p element is immediately
      followed by an address, article, aside, blockquote, details, div, dl,
      fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6,
      header, hgroup, hr, main, menu, nav, <b>ol</b>, p, pre, section, table, or
      <b>ul</b> element, or if there is no more content in the parent element
      and the parent element is an HTML element that is not an a, audio, del,
      ins, map, noscript, or video element, or an autonomous custom element.
    </blockquote>
    <p>
      这里便可以解释图上的问题了，因为p元素后面紧接着ol，ul。 因此其end
      tag被自动忽略，而进入了下一个tag（也就是ul)
    </p>
    <p>
      但是为什么呢？此时回到官方文档，可以看到p的content model为<a
        href="https://html.spec.whatwg.org/multipage/dom.html#phrasing-content-2"
        >phrasing</a
      >content，也就是说p元素内只能嵌套phrasing content。
    </p>
    <p>
      这个时候，来到<a
        href="https://html.spec.whatwg.org/multipage/grouping-content.html#the-ul-element"
        >ul的官方文档</a
      >，可以看到ul属于<a
        href="https://html.spec.whatwg.org/multipage/dom.html#flow-content-2"
        >flow content</a
      >，而不是phrasing
      content，这俩属于包含与被包含的关系。所以p内是无法嵌套任何list元素的。而这个逻辑应用于p和任何非phrasing
      content的问题
    </p>
    <p>
      类似的，可以在DevTools内看见DOM tree处，list结束的下方多出了一对p
      tag，而没有文字。这也是显示出了问题所在的
    </p>
    <div>
      <img src="Resources/DT p and ol.png" />
    </div>

    <p>
      下次若遇到相似的问题，首先可以查询官方文档来确定问题所在的tag，查询他们的content
      model与category。
    </p>

    <h2>Named character需由分号结尾</h2>
    <p>2020-07-20, 解决<a href="#1">上一个问题</a>时顺带发现的。具体如下：</p>
    <div>
      <img src="Resources/named character end.png" />
    </div>

    <p>
      在html内，有些符号是reserve给html用的，因此直接输入不会有效果（或者bug），则需要使用named
      character(entity)来代替该字符。使用大于等于号，也就是<code>&gt;</code>是由&amp;gt;来生成的（此处的&amp;则是由&amp;amp;创建的)
    </p>
    <p>
      根据<a
        href="https://html.spec.whatwg.org/multipage/syntax.html#character-references"
        >官方文档</a
      >，一切named
      character均需要由分号来结尾以保证正确的编译。否则将会导致报错，如上图。
    </p>

    <h2>Flex-grow与flex元素的最小宽度</h2>
    <h3>问题详情：</h3>
    <p>
      2022-07-25,在完成MDN的<a
        href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox_skills"
        >task4</a
      >时，我发现我达不到要求的效果，因为使用了flex：row
      wrap后，下面的button总会有空闲的空间未被占用。此时我试着使用flex:1,得到的结果也不同。按照我在mdn学习时，<code>flex</code>接受的三个值分别时对应flex-grow，flex-shrink以及flex-basis。所以我以为使用flex-grow：1和flex：1应该是一个效果。答案很明显不是。
    </p>
    <h3>解析</h3>
    <p>
      这个时候就稍微涉及到深一点的东西了，首先根据<a
        href="https://drafts.csswg.org/css-flexbox-1/#flex-property"
        >CSS specification</a
      >
      on "flex" shorthand可以看出来，与flex:1对应的是flex-grow:1, flex-shrink:1,
      flex-basis:0。
    </p>
    <p>
      <code>flex-grow:1</code
      >在此处意义不大，就是平均分配空间，但是分出区别的就是flex-basis了。这里需要了解一下，flex-basis:0代表的到底是什么.
    </p>
    <p>
      当flex-basis:0时，所有的flex
      items的最小空间为0，也就是说可分配的空间等于对应axis拥有的全部空间。此时使用flex-grow:1会将所有的items均匀分配空间，并且不由内容大小决定，这个时候就可能导致有的items内的内容看起来很挤，有的看起来很宽，但是长度都是相等的。
    </p>
    <p>
      不过，当<code>flex-basis:auto</code>，也就是默认值的时候，container内的空间会先优先分配给每一个flex
      item直到能够完全展示文字。分配剩下的空间再由<code>flex-grow</code>指定的比例来均匀分配给每一个item。具体效果如下：
    </p>
    <div>
      <img src="Resources/rel-vs-abs-flex.svg" />
    </div>
    <p>
      所以说，当我使用了<code>flex:1</code>的时候，我自动设置了<code>flex-basis:0</code>，因此按道理来说所有的flex
      items应该会按照全部空间平均分配，但是他并没有，这里先按下不提。真正的答案便是仅加上flex-grow:1，这样子就仅仅覆写它一个，默认的<code>flex-basis:auto</code>保持不变，所有的元素得到应有的空间后在对剩余空间进行分配。这便是mdn
      task的标答
    </p>
    <h3>深入</h3>
    <p>
      回到上面的问题，为什么我在mdn网页使用<code>flex:1</code>时得到的不是全部都相同大小的button呢。按照道理说，flex:1会设置flex-basis:0,因此将所有空间均匀分配。
    </p>
    <p>
      这里就要扯到css的特性了，需要知道的是，css会以不漏掉任何信息为前提给你进行styling。具体详见css
      specification内的<a
        href="https://www.w3.org/TR/css-flexbox-1/#min-size-auto"
        >flex-min-size</a
      >.说简单点便是flex
      items自带有<code>min-width:auto</code>,且优先级高于<code>flex</code>所指定的值.因此当使用了<code>flex:1</code>的时候,
      flex
      item自带的min-width使得所有元素先占据足够的位置,而不是听flex-basis的话
    </p>
    <div>
      <img src="Resources/min-width of flex.png" />
    </div>
    <p>
      那么想解决这个问题, 最简单的办法就是直接给每一个flex
      items覆写掉<code>min-width</code>, 然后便可以解决掉这个问题.
      另外一个解决方法是检查一下flex container是否指定了width,
      如果是的话可以取消掉指定的width, 然后下属的flex
      items便可以确保空间足够后进行flex-basis:0的操作.
    </p>
    <p>
      感谢，思路来源于<a
        href="https://stackoverflow.com/questions/36247140/why-dont-flex-items-shrink-past-content-size"
        >Michael Benjamin</a
      >
    </p>
    <h2>Sticky的gap问题</h2>
    <h3>问题详情：</h3>
    <p>
      2022-07-27, 当我学习sticky时, 发现我攥写的<code>positioning</code>内sticky
      index总会在上方留下一点gap,具体可见下图或<a
        href="Resources/Positioning-copy.html"
        >源码</a
      >
    </p>
    <div>
      <img src="Resources/gap with sticky.png" alt="issue: gap with sticky" />
    </div>
    <h3>解析</h3>
    <p>
      在尝试过切换浏览器,给html,body,dl,dt等取消margin和padding均无作用后.
      一篇由Sam Hermes 写的文章:<a
        href="https://samhermes.com/posts/closing-gap-above-sticky-elements/"
        >Closing the gap above sticky elements</a
      >指出了问题:
    </p>
    <blockquote>
      This issue is most visible on elements that stick to the top of the
      viewport while a user scrolls down. If the element has a solid background
      color, the gap between the element and the top of the viewport allows the
      content behind the element to be seen scrolling by. This, of course, is
      only an issue when the element with position: sticky is currently fixed.
    </blockquote>
    <blockquote>
      Fortunately, there’s a fix! This gap comes from the browser calculating
      the height of preceding elements a little too precisely. For example, say
      you’ve got a site title with a navigation directly beneath it, and that
      navigation is sticky. The height of the site title can actually have an
      effect on the navigation while it’s sticky, as the browser calculates the
      height of the site title in precise, fractional pixel values. If we set an
      even pixel height on the site title container, the gap above the sticky
      navigation will go away.
    </blockquote>
    <p>
      根据Sam Hermes的说法, 这个问题仅限于chrome,
      且是因为上一个元素的height导致的, 只需要随便设置一个height
      value给他便可解决问题.
    </p>
    <p>
      实际上, 问题的确是来源于上一个元素, 也就是h3, 但是当我尝试设置height时,
      依旧没有作用. 经过了多次是错,我发现设置一个margin
      value,不论是多大的值,均可解决问题. 使用devtools可发现很奇怪的点:
      似乎这个问题只在当margin:
      18.72px时出现,因此当我更改h3的<code>font-size</code>成18时,这个问题也可也解决,因为margin
      bottom 可能默认值是1em的原因.
    </p>
    <p>
      还有另一个思路,当我将这段问题代码塞入codepen时,发现codepen并没有这个问题,且使用手机,ipad浏览器打开均无问题,
      这个问题基本上可以结论是由于chrome的某个bug
    </p>
    <h3>嵌套内的const</h3>
    <p>
      在2022-09-12，我试图完成mdn的<a
        href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Adding_bouncing_balls_features"
        >练习</a
      >,里面要求我写一个圈圈，碰到圈后球就消失，不过我写的代码怎么样都不能移动圈圈。源码如下
    </p>
    <pre>
      function loop() {
        ctx.fillStyle = "rgba(0,0,0, 0.25)";
        ctx.fillRect(0, 0, width, height);

        const evilCircle = new EvilCircle(random(0, width), random(0, height));
        for (const ball of balls) {
          if (ball.exists) {
            ball.draw();
            ball.update();
            ball.collisionDetect();
          }
        }
        evilCircle.draw();
        evilCircle.checkBounds();
        evilCircle.collisionDetect();

        requestAnimationFrame(loop);
      }
    </pre>
    <p>
      这个函数为启动函数，使用一次后将会启动整个canvas，动效和evilcircle。由于balls是随机生成数量但evil
      circle只需要一个，所以理论上来说只需要定义一次evilcircle。但是在这里我把他放进了函数的定义内。因为我使用了<code>requestAnimationFrame()</code>，所以这个函数会无限循环，意思是我的evil
      circle也会无限循环生成，看起来就没有变化
    </p>
  </body>
</html>
